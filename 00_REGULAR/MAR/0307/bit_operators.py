# 출처 : https://travelbeeee.tistory.com/451
# bit 연산 사용
    # 1개 이상의 연속된 bit열에 대해 작업할 때(0/1로 만들거나, 비교하거나, 0/1 토글링할 때) ; & | ~ ^
    # 2**n 개념이 들어갈 때(shift operator; 2**n으로 곱하거나 나누는 작업)
    
# n이 10000보다 크면 보통 생각하는 코드에서 최적화가 필요한 경우라고 생각하면 됨
    # - 단순한 가지치기보다는 아이디어가 달라야 함
    # - 해시테이블, 비트 연산자
    # - 넣었다 뺐다하는 것이 필요하면 이렇게 보다는 linked list를 이용해 잘랐다가 붙였다가 하는 것이 좋음

# x & 1: 1과 연산하면 x를 이진수로 바꾼 것의 비트 유지; x의 비트를 가져오기
# x & 0 : 0과 연산하면 x를 이진수로 바꾼 것의 비트가 모두 0으로
# x | 1 : x에서 1인 부분은 모두 1
# x | 0 : x가 그대로 유지됨
# a ^ b : a 자리수와 b 자리수가 같으면 0, 다르면 1
    # a ^ b = 0이면 두개는 완전히 같은 수, 0이 아니면 두 수는 다른 수


## <<, >> 비트 이동 시프트 연산자
# a << b: a를 b 비트만큼 왼쪽으로 시프트; a에 2**b만큼 곱해짐
# a >> b: a를 b 비트만큼 오른쪽으로 시프트; a에 2**b만큼 나눠짐
# b: mask bit
print('-------')
print(5 << 1, 5 << 2, 5 << 3, 5 << 4)  # 10 20 40 80
print(5 >> 1, 5 >> 2, 5 >> 3, 5 >> 4)  
    # 2 1 0 0; 2**0자리수 아래로 가면 그 비트는 사라짐
    # a >> b => a를 2**b로 나눈 몫
print('-------')

a = 10  # 1010
b = 3   # 0011
c = a & b
d = a | b

print('#1')
for x in [a & b, a | b, a ^ b, ~a, a << b, a >> b]:  # 0010, 1011, 1001, 0101,
    # a << b : 1010000 => ; 뒤에 b만큼 0을 채운다
    # a >> b: 1
    # ~a: -0b1011 -11
        # 양수 : 가장 앞에 부호를 표시하는 비트도 바뀌어서 음수가 됨; 십진수가 1 커짐
        # 음수 => 양수; 십진수는 1 작아짐
    print(bin(x), x)

# bit 연산 관련 몇 가지 숙어 표현
# 출처 : http://www.jungol.co.kr/bbs/board.php?bo_table=pbank&code=3293&sca=4010

# 홀수인지 판별

print('#2')
for x in range(10, 15):
    if x & 1:  # 1010 & 1 ; 2**0번째 비트가 0이면 홀수, 1이면 짝수니까 이렇게 비교
        print(f'{x} - odd number.')


# 짝수인지 판별
print('#3')
for x in range(10, 15):
    if ~x & 1:  # ~x: 모든 비트를 반대로 반전시키는 것; 그렇기 때문에 위에 홀수 판별과 반대로 결과가 나온다
        print(f'{x} - even number.')

# x와 2**n 을 곱한 결과
print('#4')
x = 2
for n in range(2, 5):
    print(x << n)


# ⭐⭐⭐ x를 2**n 으로 나눈 몫, 나머지 구하기 ⭐⭐⭐
print('#5')
x = 123  #0b10101101
for n in range(2, 5):
    # print(x // (1 << n), x % (1 << n))  # x//(2**n), x % (2**n)
    print('몫', x >> n)
    # 몫을 구할 때 나간 비트를 가지고 나머지를 구해야 하니까 여기서는 shift left 사용
    # 그리고 그 나간 자리의 비트를 가져와야 하니까 그러러면 1들과 비교해야 함
    # 이 1들을 만들어 주기 위해 (1 << n) - 1을 쓴 것
    print('나머지', x & ((1 << n) - 1), bin(x), bin((1 << n) - 1))  
    # (1 << n) - 1 == 2**n - 1  # 0b11 0b111 0b1111
    # 나머지 3 0b1111011 0b11
    # 나머지 3 0b1111011 0b111
    # 나머지 11 0b1111011 0b1111


# (실습) x가 있었을 때 2**n으로 나눈 몫과 나머지
x = 0b11001010
for k in range(2, 5):
    a = x >> k
    b = x & ((1 << k) - 1)
    print(bin(a), bin(b), a, b)

# 3번 비트의 내용만 알고 싶다면?
x = 0b1010
# 1.
# tmp = x & (1 << 3)  # 3번 비트를 알아 낸다.
# print(x >> 3)  # 이게 그대로 3번 비트에 있으면 8로 출력되니까(1이라면) 그래서 1로 출력시키기 위해 다시 오른쪽으로 밀어준다.
# 2.
print((x>>3) & 1)

# 3번부터 이후 3비트의 내용을 알고 싶다면?
x = 0b101010
print((x >> 3) & ((1 << 3) -1))



# a, b 서로 바꾸기
print('#6')
a = 3
b = 14
print()

# ^: a,b가 서로 다른 지 같은 지 볼 때 많이 쓰임
print('#7')
a = 3
b = 6
# a = a ^ b
if not a ^ b: print('same')
else: print('different')
# print(a, b)


# a의 k번째(2의 k제곱 자리) 비트가 0인지 1인지
print('#8')
a = 10  # 1010
for n in range(3, -1, -1):
    # tmp = a & (1 << n)
    # print(tmp >> n, end=' ')
    print((a >> n) & 1, end=' ')
print()

# a의 k번째(2의 k제곱 자리) 비트만 0이면 1로, 1이면 0으로 바꾸고
print('#9')
a = 0b1010  # 1010 => 0101로
for n in range(4):
    print(a ^ (1 << n), bin(a ^ (1 << n)))

print()
# a가 2의 제곱수인지 판별
# 0b10000  0b1000  0b100  0b10  0b1 (a)
# 0b01111  0b0111  0b011  0b01  0b0 (a-1)
# => a & a-1 == 0의 관계임; 즉 하나 뺀 것과 모든 비트가 다름
print('#10')
for a in range(1, 10):
    if not (a & (a-1)):
        print(a, end=' ')
print()

# 나중에 해보기
# a와 b의 같은 자리 비트를 비교한 결과 서로 다른 비트가 1개 이하인지
a = 0xF
for b in range(15):
    result = 000
    if not result:
        print(f'{a} {bin(a)} and {b} {bin(b)} differ by below 1 bit.')


ht = {0: 1, 111: 2, 10: 3, 110: 4}
x = ht.get(110, -1)
print(x)

now = 0b10
for kk in range(3):

    # adj = int(bin(now ^ (1 << kk))[2:])
    print('t', now ^ (1 <<kk))
    print(now ^ (1 << kk))
    # print(adj)